@using BlazorInteractive.Components.Editor
@using BlazorInteractive.Components.Output
@using System.Text.RegularExpressions

@page "/"

@inject IToastService ToastService
@inject ICompiler CodeCompiler
@inject IAssemblyInvoker AssemblyInvoker
@inject IReferenceFilter ReferenceFilter

<PageTitle>Index</PageTitle>

<div class="container">
    <EditorComponent OnCompile="OnCompileAsync" References="References"></EditorComponent>
    <br />
    <OutputComponent Content="@output" OutputClass="@outputClass"></OutputComponent>
</div>

@code {
    private string? output = string.Empty;
    private string? outputClass = string.Empty;
    private List<string> References = new List<string>();

    protected async override Task OnInitializedAsync()
    {
        var referencesResult = await ReferenceFilter.GetReferencesAsync(CancellationToken.None);
        referencesResult.Switch(
            references => {
                References = references.ToList();
            },
            failure => {
                ToastService.ShowError(failure.errorMessage);
            },
            cancelled => {
                ToastService.ShowInfo("Cancelled");
            }
        );
    }

    private async Task OnCompileAsync(CompilationArgs args)
    {
        output = string.Empty;

        const string sourceCodeFormat = @"
        using System;
        {0}

        namespace BlazorInteractive
        {{
            public class Program
            {{
                public static void Main()
                {{
                    {1}
                }}
            }}
        }}
        ";

        var lines = args.SourceCode.Split(System.Environment.NewLine);

        var usingPattern = new Regex(@"^\s*using\s+([\w\d\.]+)\s*;\s*$");
        var grouped = lines.GroupBy(line => usingPattern.IsMatch(line));
        var usings = grouped.Where(group => group.Key).FirstOrDefault()?.Select(x => x);
        var mainMethod = grouped.Where(group => !group.Key).FirstOrDefault()?.Select(x => x);

        var sourceCode = string.Format(
            sourceCodeFormat,
            (usings is null) ? string.Empty : string.Join(System.Environment.NewLine, usings),
            (mainMethod is null) ? string.Empty : string.Join(System.Environment.NewLine, mainMethod));

        await Task.Run(async () => {
            var compilationResult = await CodeCompiler.CompileAsync(sourceCode, args.References, args.CancellationToken);

            output = compilationResult.Match(
                assembly => {
                    outputClass = "success";
                    return AssemblyInvoker.Invoke(assembly, "BlazorInteractive.Program", "Main");
                },
                @void => {
                    outputClass = "";
                    return string.Empty;
                },
                failure => {
                    outputClass = "error";
                    //return failure.Exception?.Message;
                    return failure.errorMessage;
                },
                cancelled => {
                    outputClass = "warning";
                    return string.Empty;
                }
            );
        }, args.CancellationToken);
    }
}